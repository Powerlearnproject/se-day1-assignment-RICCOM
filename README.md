[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18398424&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering  is writing  instructions(code), building apps,games and websites that  make our lives easier.It helps solve real world problems through technology

Identify and describe at least three key milestones in the evolution of software engineering.
1.Birth of Software Engineering (1968) – The NATO Conference introduced software engineering to address the growing software crisis. It recognized software development as 
  an engineering discipline.
2.Structured Programming (1970s–1980s) – Developers adopted structured programming to improve code reliability. Modularization and control structures replaced unstructured 
  coding.
3.Agile Methodologies (2001) – The Agile Manifesto introduced iterative development and continuous feedback. Agile frameworks like Scrum and Kanban improved software 
  adaptability.
List and briefly explain the phases of the Software Development Life Cycle.
 1.Planning – Define project goals, scope, and feasibility. Identify resources, risks, and timelines.
 2.Requirement Analysis – Gather and document software requirements. Ensure clarity between stakeholders and developers.
 3.Design – Create system architecture, UI/UX design, and database structure. Plan how components will interact.
 4.Implementation (Coding) – Developers write and integrate code based on the design specifications.
 5.Testing – Identify and fix bugs through unit, integration, and system testing. Ensure software meets requirements.
 6.Deployment – Release the software for users. This can be done in phases or all at once.
 7.Maintenance – Fix issues, update features, and ensure system performance over time.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
   The Waterfall methodology follows a sequential, step-by-step approach where each phase (planning, design, development, testing, and deployment) must be completed before moving to the next. It is rigid, making changes difficult once development starts, and testing occurs only after the software is fully built. Customer involvement is minimal, and it is best suited for large, well-defined projects like banking systems that require extensive documentation and fixed requirements. In contrast, Agile is iterative and highly flexible, allowing for continuous feedback and adaptation throughout development. Testing happens frequently, and customers are involved at every stage, making it ideal for projects with evolving requirements, such as mobile app development, where user feedback drives regular updates.
   Waterfall Example: Developing a banking system where requirements are fixed and extensive documentation is required.
   Agile Example: Building a mobile app startup where customer feedback drives frequent updates and feature changes.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
   Software Developer – Writes, tests, and optimizes code to build software solutions.
   QA Engineer – Ensures software quality through testing and bug identification.
   Project Manager – Oversees development, manages teams, and ensures project success.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
  IDEs enhance coding efficiency with tools like editors and debuggers (e.g., VS Code, PyCharm).
  VCS tracks code changes, enabling collaboration and rollback (e.g., Git, GitHub).

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
  Debugging and Fixing Bugs – Use debugging tools, log errors systematically, and write test cases to catch issues early.
  Managing Changing Requirements – Adopt Agile methodologies, maintain clear documentation, and have regular stakeholder communication.
  Meeting Deadlines – Use project management tools (e.g., Jira, Trello), set realistic goals, and prioritize tasks effectively.
  Security Risks – Follow best security practices, conduct regular code reviews, and use encryption for sensitive data.
  Collaboration in Teams – Use version control (e.g., Git), have clear coding standards, and communicate effectively via meetings and chat tools.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
  Unit Testing – Tests individual components or functions to ensure they work correctly. It helps catch bugs early.
  Integration Testing – Verifies that different modules work together properly. It ensures smooth data flow between components.
  System Testing – Tests the entire application as a whole to check compliance with requirements. It validates overall functionality.
  Acceptance Testing – Confirms if the software meets user needs and business requirements. It determines if the product is ready for release.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
  Prompt Engineering designs clear prompts to improve AI responses. It enhances accuracy, efficiency, AI capabilities, and user experience, making interactions more 
  effective.
Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
  A vague prompt "Tell me about technology." . Improved prompt "Explain how AI is transforming healthcare with examples." makes it clear, specific, and concise, leading to a more relevant and useful response.
